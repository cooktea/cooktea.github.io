---
title: 从零开始用C++写即时聊天(架构设计)
date: 2022-02-13
categories:
- Learning Something
---

# 网络模型
由于使用了grpc作为客户端和服务端的通信框架，所以本文并不会讨论应该使用什么样的网络IO模型。  
虽然不会讨论使用什么样的网络IO模型，不过grpc提供了同步和异步两种网络模式（流模式先不考虑吧，主要是不会用）。所以这一节先决定使用同步网络模型还是异步网络模型。
## 同步Rpc
众所周知，同步网络会导致网络阻塞，但是代码写起来很简单。既然会有网络阻塞导致的问题，这就意味着在rpc返回结果之前，程序会一致保持阻塞状态，如果网络环境很不好的话，就会导致后续的代码无法执行。这时候如果没有把网络io作为独立的线程或进程从主线程上分离出去的话，就会导致程序无响应。这对于用户的体验来说是很难接受的一件事。如果是服务端的话，一旦任何一个rpc需要长时间执行，就会导致这个rpc的来源客户端一直阻塞。
## 异步Rpc
异步rpc的有点是客户端发送rpc后不需要等待返回即可执行后续的代码，当rpc返回后再执行对应的逻辑。这样做的好处是在单线程的客户端程序中，rpc不会阻塞其他模块的继续运行，比如UI刷新等。缺点是异步的逻辑比较难以编写，Debug起来也比较困难。
## 如何选择
出于简化项目架构，且降低项目整体难度的目的。服务端选择同步网络模型，客户端选择异步网络模型。之所以两端选择网络模型不一致，主要原因如下。
### 服务端
- 服务端对于单个进程的性能不太敏感，可以使用多开服务进程并在前端接入负载均衡降低单个服务进程的压力。
- 服务端的逻辑比较复杂，使用同步网络模型对于代码编写，Debug来说都比较友好。
- 服务端很少需要主动向客户端发送rpc请求，由于同步导致的阻塞概率较小。
### 客户端
- 客户端除了需要跟服务端进行网络通信以外，还需要执行GUI相关的逻辑。在不考虑另开网络线程的情况下，为了避免因rpc阻塞导致的程序失去响应，所以选择异步模型。
- 客户端主动发送rpc的频率比较高，且可能向不同的服务器发送请求。为了避免单个rpc阻塞导致的木桶效应，所以选择异步模型。
  
# 进程模型
单进程还是多进程、单线程还是多线程，永远都是程序开发过程中绕不过去的一个问题。本节将根据客户端与服务端业务特点分别讨论究竟应该使用什么样的进程模型。  
`Tips：这里的进程仅讨论是否需要根据不同的业务逻辑编写不同的业务进程。`
## 服务端
### 特点分析
1. 服务端进程运行在服务器上，并通过端口向外网暴露服务。
2. 内网环境下进程与进程之间网络较稳定，带宽够大、延时够低。
3. 单个进程往往需要给多个客户端提供服务。
4. 不同业务需求之间的压力不一致：聊天 > (加好友, 登录注册) >  统计。

可以发现，服务端的业务逻辑特点似乎非常适合使用多进程模型进行开发。但是需要额外处理不同业务之间需要使用同一份玩家数据的情况。针对这个问题，似乎可以通过redis之类的内存数据库进行一些热点数据的缓存。不过这样就引入了额外的第三方服务，添加了整体的复杂性。  
如果使用单进程模型，那么需要将所有的业务逻辑都在同一个进程上运行，如果进程的负载过大或crash，那么经过负载均衡后到达该进程的所有请求将被阻塞或丢失。同时，如果数据库读写的逻辑也在该进程实现的话，那么必然会由于数据库的同步操作导致进程被阻塞。高频的数据库操作甚至有可能导致进程大部分的cpu时间被用于数据库返回。  
综上所述，单进程的优势是可以将用户的数据在缓存在内存中，所有需要使用该数据的逻辑都可以快速的从内存中获取，但是类似数据库操作的同步逻辑必然会阻塞进程，导致进程的响应时间变得更长。  
多进程的优势是可以将业务逻辑拆分，将同步的操作通过rpc callback的方式转变为异步操作。但是多进程需要额外处理进程与进程间的通信问题。且需要引入一些第三方的服务保证数据统一。增加了服务端整体架构的复杂度。  
经过考虑，最终决定选择单进程与多进程结合的方式。主要的业务逻辑在单个进程中运行，其他可能造成同步阻塞的逻辑，例如数据库读写等放在另外的进程中运行。进程间通过rpc callback的方式异步调用。  
![](https://cooktea.github.io/assets/images/cpp-im-server-进程模型.jpg)

## 客户端
